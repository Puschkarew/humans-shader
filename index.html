<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Organic Bokeh Field</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=IBM+Plex+Mono:wght@400;600&display=swap");

      :root {
        --panel-bg: rgba(12, 12, 16, 0.72);
        --panel-border: rgba(255, 255, 255, 0.12);
        --panel-highlight: rgba(253, 168, 126, 0.18);
        --panel-text: #f6f1eb;
        --panel-muted: rgba(246, 241, 235, 0.65);
        --panel-accent: #f6b08b;
        --panel-accent-strong: #f88e6b;
      }

      html, body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      body {
        background: #FFAAA5;
      }

      canvas#gl {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        display: block;
      }

      .control-panel {
        position: fixed;
        top: 24px;
        right: 24px;
        width: 320px;
        max-height: calc(100vh - 48px);
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 16px;
        border-radius: 20px;
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        backdrop-filter: blur(16px);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
        color: var(--panel-text);
        font-family: "Space Grotesk", "Segoe UI", sans-serif;
        z-index: 10;
      }

      .control-panel * {
        box-sizing: border-box;
      }

      .panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .panel-title {
        font-size: 18px;
        font-weight: 600;
        letter-spacing: 0.01em;
      }

      .panel-subtitle {
        font-size: 12px;
        color: var(--panel-muted);
        margin-top: 2px;
      }

      .panel-toggle {
        appearance: none;
        background: rgba(255, 255, 255, 0.1);
        color: var(--panel-text);
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 999px;
        padding: 6px 12px;
        font-size: 12px;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .panel-toggle:hover {
        transform: translateY(-1px);
        background: rgba(255, 255, 255, 0.18);
      }

      .panel-body {
        display: flex;
        flex-direction: column;
        gap: 16px;
        overflow: auto;
        padding-right: 4px;
        scrollbar-width: thin;
        scrollbar-color: rgba(246, 176, 139, 0.9) transparent;
      }

      .panel-body::-webkit-scrollbar {
        width: 10px;
      }

      .panel-body::-webkit-scrollbar-track {
        background: transparent;
      }

      .panel-body::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, rgba(246, 176, 139, 0.88), rgba(248, 142, 107, 0.76));
        border-radius: 6px;
        border: none;
        min-height: 32px;
      }

      .panel-body::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(180deg, rgba(246, 176, 139, 0.96), rgba(248, 142, 107, 0.9));
      }

      #controlSections {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .panel-section {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 12px;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.06);
      }

      .section-title {
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--panel-muted);
      }

      .control-row {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
      }

      .control-label {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 13px;
        color: var(--panel-text);
      }

      .control-value {
        font-family: "IBM Plex Mono", "SFMono-Regular", monospace;
        font-size: 12px;
        color: var(--panel-muted);
      }

      .control-input {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .control-input input[type="range"] {
        width: 100%;
        accent-color: var(--panel-accent);
      }

      .control-input input[type="color"] {
        width: 44px;
        height: 28px;
        border: none;
        border-radius: 8px;
        background: transparent;
        padding: 0;
        cursor: pointer;
      }

      .control-input input[type="checkbox"] {
        width: 18px;
        height: 18px;
        margin: 0;
        accent-color: var(--panel-accent);
      }

      .stat-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 13px;
      }

      .stat-value {
        font-family: "IBM Plex Mono", "SFMono-Regular", monospace;
        color: var(--panel-muted);
      }

      .panel-actions {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .reset-button {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: transparent;
        color: var(--panel-text);
        border-radius: 10px;
        padding: 8px 14px;
        font-size: 12px;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease;
      }

      .reset-button:hover {
        transform: translateY(-1px);
        background: var(--panel-highlight);
      }

      .panel-hint {
        font-size: 11px;
        color: var(--panel-muted);
      }

      .control-panel.collapsed {
        width: 180px;
      }

      .control-panel.collapsed .panel-body {
        display: none;
      }

      @media (max-width: 720px) {
        .control-panel {
          top: auto;
          bottom: 16px;
          right: 16px;
          left: 16px;
          width: auto;
          max-height: 45vh;
        }
      }
    </style>
  </head>
  <body>
    <canvas
      id="gl"
      role="img"
      aria-label="WebGL organic bokeh animation on warm gradient background"
    ></canvas>

    <div class="control-panel" id="controlPanel" aria-label="Effect controls">
      <div class="panel-header">
        <div>
          <div class="panel-title">Effect Controls</div>
          <div class="panel-subtitle">Organic Bokeh Field</div>
        </div>
        <button class="panel-toggle" id="panelToggle" type="button">Hide</button>
      </div>
      <div class="panel-body">
        <div id="controlSections"></div>

        <div class="panel-section" id="resourceSection">
          <div class="section-title">Resources</div>
          <div class="stat-row"><span>FPS</span><span class="stat-value" id="statFps">--</span></div>
          <div class="stat-row"><span>Frame time</span><span class="stat-value" id="statFrame">--</span></div>
          <div class="stat-row"><span>Render size</span><span class="stat-value" id="statRender">--</span></div>
          <div class="stat-row"><span>Render pixels</span><span class="stat-value" id="statPixels">--</span></div>
          <div class="stat-row"><span>RES scale</span><span class="stat-value" id="statResScale">--</span></div>
          <div class="stat-row"><span>DPR</span><span class="stat-value" id="statDpr">--</span></div>
          <div class="stat-row"><span>Passes</span><span class="stat-value" id="statPasses">6</span></div>
        </div>

        <div class="panel-actions">
          <button class="reset-button" id="resetControls" type="button">Reset</button>
          <div class="panel-hint">Auto-saved</div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        const DEFAULTS = {
          RES_SCALE: 0.4,
          DPR_MAX: 1,
          POINTER_SMOOTHING: 0.1,
          BG_COLOR: "#A4606A",
          PARTICLE_CENTER_COLOR: "#FFE59E",
          PARTICLE_EDGE_COLOR: "#4D0037",
          PARTICLE_RADIUS: 0.31,
          PARTICLE_SOFTNESS: 0.2,
          PARTICLE_EDGE_SMOOTHNESS: 1.2,
          PARTICLE_CONTOUR_NOISE: 0.46,
          PARTICLE_REVEAL_TIME: 0.12,
          PARTICLE_FADE_TIME: 0.9,
          BG_TEXTURE_ENABLED: 1,
          SINE_FREQUENCY: 0.35,
          SINE_AMPLITUDE: 1.18,
          SINE_FALLOFF: 0.5,
          SINE_ROTATION: 0.0,
          SINE_PHASE: 0.0,
          SINE_SPEED: 0.1,
          SINE_MIX_RADIUS: 1.0,
          SINE_TRACK_MOUSE: 0.0,
          SHATTER_SCALE: 0.25,
          SHATTER_AMOUNT: 1.0,
          SHATTER_ANGLE: 44.0,
          SHATTER_RADIUS: 1.0,
          SHATTER_SKEW: 0.84,
          SHATTER_MIX_RADIUS: 1.0,
          SHATTER_MIX_INVERT: 0,
          BOKEH_RADIUS: 1.41,
          BOKEH_TILT: 0.5,
          BOKEH_MIX_RADIUS: 1.0,
          BOKEH_TRACK_MOUSE: 0.0
        };

        const STORAGE_KEY = "bokeh-controls-v4-particle";

        function cloneDefaults() {
          return { ...DEFAULTS };
        }

        function applySavedConfig(target, saved) {
          if (!saved || typeof saved !== "object") {
            return target;
          }
          Object.keys(target).forEach((key) => {
            const baseValue = target[key];
            const savedValue = saved[key];
            if (typeof baseValue === "number") {
              const num = Number(savedValue);
              if (Number.isFinite(num)) {
                target[key] = num;
              }
              return;
            }
            if (typeof baseValue === "string" && typeof savedValue === "string") {
              target[key] = savedValue;
            }
          });
          return target;
        }

        function loadConfig() {
          const config = cloneDefaults();
          try {
            const raw = window.localStorage.getItem(STORAGE_KEY);
            if (!raw) {
              return config;
            }
            return applySavedConfig(config, JSON.parse(raw));
          } catch (err) {
            return config;
          }
        }

        const config = loadConfig();
        const INTERNAL_SHAPE = {
          FALL_OFF: 1.0,
          SKEW: 0.54,
          ANGLE: 0.0,
          EDGE_NOISE_SCALE: 2.8,
          EDGE_AA: 0.95
        };

        function saveConfig() {
          try {
            window.localStorage.setItem(STORAGE_KEY, JSON.stringify(config));
          } catch (err) {
            // Ignore storage errors.
          }
        }

        const canvas = document.getElementById("gl");
        const gl = canvas.getContext("webgl2", {
          antialias: false,
          alpha: false,
          premultipliedAlpha: false,
          preserveDrawingBuffer: false
        });

        if (!gl) {
          console.warn("WebGL2 not supported");
          return;
        }

        const vertexShaderSource = `#version 300 es
          precision highp float;
          layout(location=0) in vec2 aPosition;
          out vec2 vUv;
          void main() {
            vUv = aPosition * 0.5 + 0.5;
            gl_Position = vec4(aPosition, 0.0, 1.0);
          }
        `;

        const backgroundFragmentSource = `#version 300 es
          precision highp float;
          in vec2 vUv;
          out vec4 fragColor;
          uniform vec3 uBgColor;
          void main() {
            fragColor.rgb = uBgColor;
            fragColor.a = 1.0;
          }
        `;

        const revealFragmentSource = `#version 300 es
          precision highp float;
          #define TWO_PI 6.28318530718
          in vec2 vUv;
          out vec4 fragColor;
          uniform sampler2D tPrevReveal;
          uniform sampler2D tBlueNoise;
          uniform vec2 uPointerPos;
          uniform float uPointerActive;
          uniform float uDt;
          uniform float uRadius;
          uniform float uSoftness;
          uniform float uEdgeSmoothness;
          uniform float uFalloff;
          uniform float uSkew;
          uniform float uAngle;
          uniform float uRevealTime;
          uniform float uFadeTime;
          uniform vec3 uCenterColor;
          uniform vec3 uEdgeColor;
          uniform vec2 uResolution;
          uniform vec2 uBlueNoiseResolution;
          uniform float uEdgeNoiseStrength;
          uniform float uEdgeNoiseScale;
          uniform float uEdgeAA;
          mat2 rot(float a) {
            return mat2(cos(a), -sin(a), sin(a), cos(a));
          }
          float sampleBlueNoise(vec2 uv, float scale) {
            ivec2 texSize = ivec2(max(uBlueNoiseResolution, vec2(1.0)));
            vec2 scaled = uv * uResolution * scale * vec2(float(texSize.x) / float(texSize.y), 1.0);
            ivec2 noiseCoord = ivec2(fract(scaled / vec2(texSize)) * vec2(texSize)) % texSize;
            return texelFetch(tBlueNoise, noiseCoord, 0).r * 2.0 - 1.0;
          }
          void main() {
            vec4 prev = texture(tPrevReveal, vUv);
            vec2 aspectRatio = vec2(uResolution.x / uResolution.y, 1.0);
            vec2 skew = vec2(uSkew, 1.0 - uSkew);
            float halfRadius = uRadius * 0.5;
            float innerEdge = halfRadius - uFalloff * halfRadius * 0.5;
            float outerEdge = halfRadius + uFalloff * halfRadius * 0.5;
            vec2 scaledUV = vUv * aspectRatio * rot(uAngle * TWO_PI) * skew;
            vec2 scaledPos = uPointerPos * aspectRatio * rot(uAngle * TWO_PI) * skew;
            float radius = distance(scaledUV, scaledPos);
            float aa = max(fwidth(radius) * max(uEdgeAA, 0.001), 0.0005);
            float previewFalloff = smoothstep(innerEdge - aa, outerEdge + aa, radius);
            float previewProfile = clamp(1.0 - previewFalloff, 0.0, 1.0);
            float contourBand = pow(clamp(1.0 - abs(previewProfile * 2.0 - 1.0), 0.0, 1.0), 0.55);
            float contourMask = mix(0.12, 1.0, contourBand);
            float noiseA = sampleBlueNoise(vUv, max(uEdgeNoiseScale, 0.001));
            float noiseB = sampleBlueNoise(vUv + vec2(0.37, 0.19), max(uEdgeNoiseScale * 2.1, 0.001));
            float edgeNoise = (noiseA * 0.72 + noiseB * 0.28) * uEdgeNoiseStrength * contourMask;
            float falloff = smoothstep(innerEdge - aa, outerEdge + aa, radius + edgeNoise * halfRadius * 1.15);
            float baseProfile = clamp(1.0 - falloff, 0.0, 1.0);
            float alphaProfile = pow(baseProfile, max(uSoftness, 0.001));
            float edgeProfile = pow(baseProfile, max(uEdgeSmoothness, 0.001));
            float targetAlphaActive = alphaProfile;
            float pointerEnabled = step(0.5, uPointerActive);
            float targetAlpha = mix(0.0, targetAlphaActive, pointerEnabled);
            float targetColorMix = mix(0.0, 1.0 - edgeProfile, pointerEnabled);
            vec3 targetColor = mix(uCenterColor, uEdgeColor, targetColorMix);
            float revealTime = max(uRevealTime, 0.001);
            float revealK = 1.0 - exp(-uDt / revealTime);
            float fadeTime = max(uFadeTime, 0.001);
            float fadeK = 1.0 - exp(-uDt / fadeTime);
            float clearK = 1.0 - exp(-uDt / max(uRevealTime * 0.35, 0.001));
            float toBackground = step(prev.a, targetAlpha);
            float activeK = mix(revealK, clearK, toBackground);
            float alphaK = mix(fadeK, activeK, pointerEnabled);
            float nextAlpha = mix(prev.a, targetAlpha, alphaK);
            vec3 nextColor = mix(prev.rgb, targetColor, alphaK);
            fragColor = vec4(nextColor, nextAlpha);
          }
        `;

        const sineFragmentSource = `#version 300 es
          precision mediump float;
          #define PI 3.141592
          #define PI3 1.04709283144
          in vec2 vUv;
          uniform sampler2D tInput;
          uniform float uMixRadius;
          uniform vec2 uPos;
          uniform float uFrequency;
          uniform float uAmplitude;
          uniform float uRotation;
          uniform float uTime;
          uniform vec2 uResolution;
          uniform vec2 uMousePos;
          uniform float uTrackMouse;
          out vec4 fragColor;
          void main() {
            vec2 uv = vUv;
            vec2 waveCoord = vUv.xy * 2.0 - 1.0;
            float time = uTime * 0.25;
            float frequency = 20.0 * uFrequency;
            float amp = uAmplitude * 0.2;
            float waveX = sin((waveCoord.y + uPos.y) * frequency + (time * PI3)) * amp;
            float waveY = sin((waveCoord.x - uPos.x) * frequency + (time * PI3)) * amp;
            waveCoord.xy += vec2(mix(waveX, 0.0, uRotation), mix(0.0, waveY, uRotation));
            vec2 finalUV = waveCoord * 0.5 + 0.5;
            float aspectRatio = uResolution.x / uResolution.y;
            vec2 mPos = uPos + mix(vec2(0.0), (uMousePos - 0.5), uTrackMouse);
            vec2 pos = mix(uPos, mPos, floor(uMixRadius));
            float dist = (max(0.0, 1.0 - distance(uv * vec2(aspectRatio, 1.0), mPos * vec2(aspectRatio, 1.0)) * 4.0 * (1.0 - uMixRadius)));
            uv = mix(uv, finalUV, dist);
            fragColor = texture(tInput, uv);
          }
        `;

        const shatterFragmentSource = `#version 300 es
          precision mediump float;
          // Adapted From https://www.unicorn.studio/edit/g3lEVXT6g6U6duHP3YRy?from=template
          #define PI 3.14159265359
          in vec2 vUv;
          uniform sampler2D tInput;
          uniform float uAmount;
          uniform float uSpread;
          uniform float uAngle;
          uniform float uTime;
          uniform float uSkew;
          uniform vec2 uPos;
          uniform vec2 uResolution;
          uniform float uMixRadius;
          uniform int uMixRadiusInvert;
          uniform int uEasing;
          uniform vec2 uMousePos;
          uniform float uTrackMouse;
          vec2 random2(vec2 p) {
            return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);
          }
          mat2 rot(float a) {
            return mat2(cos(a), -sin(a), sin(a), cos(a));
          }
          out vec4 fragColor;
          void main() {
            vec2 uv = vUv;
            float aspectRatio = uResolution.x / uResolution.y;
            vec2 skew = mix(vec2(1.0), vec2(1.0, 0.0), uSkew);
            vec2 st = (uv - uPos) * vec2(aspectRatio, 1.0) * 50.0 * uAmount;
            st = st * rot(uAngle * 2.0 * PI) * skew;
            vec2 i_st = floor(st);
            vec2 f_st = fract(st);
            float m_dist = 15.0;
            vec2 m_point;
            vec2 d;
            for (int j = -1; j <= 1; j++) {
              for (int i = -1; i <= 1; i++) {
                vec2 neighbor = vec2(float(i), float(j));
                vec2 point = random2(i_st + neighbor);
                point = 0.5 + 0.5 * sin(5.0 + uTime * 0.2 + 6.2831 * point);
                vec2 diff = neighbor + point - f_st;
                float dist = length(diff);
                if (dist < m_dist) {
                  m_dist = dist;
                  m_point = point;
                  d = diff;
                }
              }
            }
            vec2 offset = (m_point * 0.2 * uSpread * 2.0) - (uSpread * 0.2);
            vec2 mPos = uPos + mix(vec2(0.0), (uMousePos - 0.5), uTrackMouse);
            vec2 pos = mix(uPos, mPos, floor(uMixRadius));
            float dist = (max(0.0, 1.0 - distance(uv * vec2(aspectRatio, 1.0), mPos * vec2(aspectRatio, 1.0)) * 4.0 * (1.0 - uMixRadius)));
            vec4 color = texture(tInput, uv + offset * dist);
            fragColor = color;
          }
        `;

        const bokehFragmentSource = `#version 300 es
          precision highp float;
          in vec2 vUv;
          out vec4 fragColor;
          #define PI2 6.28318530718
          #define ITERATIONS 50.0
          #define GOLDEN_ANGLE 2.39996323
          uniform sampler2D tInput;
          uniform sampler2D tBgTexture;
          uniform sampler2D tBlueNoise;
          uniform float uAmount;
          uniform float uTilt;
          uniform float uTime;
          uniform vec2 uPos;
          uniform int uPass;
          uniform vec2 uResolution;
          uniform vec2 uMousePos;
          uniform float uTrackMouse;
          uniform vec2 uBlueNoiseResolution;
          vec2 Sample(in float theta, inout float r) {
            r += 1.0 / r;
            return (r - 1.0) * vec2(cos(theta), sin(theta));
          }
          float getBlueNoiseOffset(vec2 st) {
            ivec2 texSize = ivec2(uBlueNoiseResolution);
            vec4 blueNoise = texelFetch(tBlueNoise, ivec2(fract(st * (uResolution) / vec2(texSize) * vec2(texSize.x / texSize.y, 1.0)) * vec2(texSize)) % texSize, 0);
            return mod((blueNoise.r - 0.5) * PI2, PI2);
          }
          vec4 Bokeh(sampler2D tex, vec2 uv, float blurRadius) {
            vec3 accumulatedColor = vec3(0.0);
            vec3 accumulatedWeights = vec3(0.0);
            float accumulatedAlpha = 0.0;
            float aspectRatio = uResolution.x / uResolution.y;
            vec2 pixelSize = vec2(1.0 / aspectRatio, 1.0) * 0.04 * 0.075;
            float r = 1.0;
            float noiseOffset = (getBlueNoiseOffset(uv) - 0.5) * 0.01;
            float noiseAngle = noiseOffset * PI2;
            mat2 rotationMatrix = mat2(
              cos(noiseAngle), -sin(noiseAngle),
              sin(noiseAngle), cos(noiseAngle)
            );
            for (float j = 0.0; j < GOLDEN_ANGLE * ITERATIONS; j += GOLDEN_ANGLE) {
              vec2 offset = Sample(j, r) * pixelSize;
              float jitterAmount = 0.05 * (sin(j * 0.1) * 0.5 + 0.5);
              offset *= 1.0 + jitterAmount * sin(j * 0.7 + noiseOffset);
              vec2 sampleOffset = rotationMatrix * offset;
              vec4 colorSample = texture(tex, uv + sampleOffset);
              vec3 bokehWeight = vec3(5.0) + pow(colorSample.rgb, vec3(9.0)) * 150.0;
              accumulatedAlpha += colorSample.a;
              accumulatedColor += colorSample.rgb * bokehWeight;
              accumulatedWeights += bokehWeight;
            }
            return vec4(accumulatedColor / accumulatedWeights, accumulatedAlpha / ITERATIONS);
          }
          void main() {
            vec2 uv = vUv;
            if (uAmount == 0.0) {
              fragColor = vec4(0.0);
              return;
            }
            vec2 pos = uPos + mix(vec2(0.0), (uMousePos - 0.5), uTrackMouse);
            float dis = distance(uv, pos) * 1000.0;
            float tilt = mix(1.0 - dis * 0.001, dis * 0.001, uTilt);
            float blurRadius = uAmount * tilt;
            fragColor = Bokeh(tInput, uv, blurRadius);
          }
        `;

        const outputFragmentSource = `#version 300 es
          precision highp float;
          in vec2 vUv;
          out vec4 fragColor;
          uniform sampler2D tBgTexture;
          uniform sampler2D tBlueNoise;
          uniform vec3 uBgColor;
          uniform sampler2D tInput;
          uniform vec3 uCenterColor;
          uniform int uBgTextureEnabled;
          uniform int uLoaded;
          uniform vec2 uResolution;
          uniform vec2 uBlueNoiseResolution;
          uniform float uContourNoise;
          float sampleBlueNoise(vec2 uv, float scale) {
            ivec2 texSize = ivec2(max(uBlueNoiseResolution, vec2(1.0)));
            vec2 texelUv = (uv * uResolution / vec2(texSize)) * scale;
            vec2 tiled = fract(texelUv * vec2(float(texSize.x) / float(texSize.y), 1.0));
            ivec2 noiseCoord = ivec2(tiled * vec2(texSize)) % texSize;
            return texelFetch(tBlueNoise, noiseCoord, 0).r * 2.0 - 1.0;
          }
          vec3 overlay(vec3 base, vec3 blend) {
            return mix(
              2.0 * base * blend,
              1.0 - 2.0 * (1.0 - base) * (1.0 - blend),
              step(0.5, base)
            );
          }
          void main() {
            vec3 base = uBgColor;
            if (uLoaded == 1 && uBgTextureEnabled == 1) {
              vec3 bgTex = texture(tBgTexture, vUv).rgb;
              base = mix(uBgColor, overlay(uBgColor, bgTex), 0.61);
            }
            vec4 particle = texture(tInput, vUv);
            float particleAlpha = clamp(particle.a, 0.0, 1.0);
            float edgeBand = pow(clamp(1.0 - abs(particleAlpha * 2.0 - 1.0), 0.0, 1.0), 0.34);
            float noiseA = sampleBlueNoise(vUv + vec2(particleAlpha * 0.13, 0.0), 3.4);
            float noiseB = sampleBlueNoise(vUv + vec2(0.29, 0.47), 7.8);
            float contourNoise = noiseA * 0.74 + noiseB * 0.26;
            float contourStrength = uContourNoise * (0.85 + uContourNoise * 1.6);
            float contourJitter = contourNoise * contourStrength * edgeBand * 0.95;
            float noisyAlpha = clamp(particleAlpha + contourJitter, 0.0, 1.0);
            vec3 blend = mix(vec3(1.0), particle.rgb, noisyAlpha);
            vec3 multiplied = base * mix(vec3(1.0), blend, 0.26);
            vec3 emissive = particle.rgb * noisyAlpha * 0.18;
            float centerWhiteness = smoothstep(0.88, 1.0, min(uCenterColor.r, min(uCenterColor.g, uCenterColor.b)));
            float coreMask = pow(noisyAlpha, 2.2);
            vec3 whiteCore = vec3(1.0) * coreMask * centerWhiteness * 0.42;
            vec3 gentleTint = particle.rgb * coreMask * 0.06;
            float contourAccent = clamp(contourStrength * edgeBand, 0.0, 1.0);
            vec3 contourGrain = vec3(contourNoise) * contourAccent * 0.12;
            vec3 contourShadow = vec3(-1.0) * max(0.0, -contourNoise) * contourAccent * 0.06;
            fragColor.rgb = clamp(multiplied + emissive + gentleTint + whiteCore + contourGrain + contourShadow, 0.0, 1.0);
            fragColor.a = 1.0;
          }
        `;

        function createShader(glContext, type, source) {
          const shader = glContext.createShader(type);
          glContext.shaderSource(shader, source);
          glContext.compileShader(shader);
          if (!glContext.getShaderParameter(shader, glContext.COMPILE_STATUS)) {
            const info = glContext.getShaderInfoLog(shader);
            glContext.deleteShader(shader);
            throw new Error(info);
          }
          return shader;
        }

        function createProgram(glContext, vertexSource, fragmentSource) {
          const vertexShader = createShader(glContext, glContext.VERTEX_SHADER, vertexSource);
          const fragmentShader = createShader(glContext, glContext.FRAGMENT_SHADER, fragmentSource);
          const program = glContext.createProgram();
          glContext.attachShader(program, vertexShader);
          glContext.attachShader(program, fragmentShader);
          glContext.linkProgram(program);
          if (!glContext.getProgramParameter(program, glContext.LINK_STATUS)) {
            const info = glContext.getProgramInfoLog(program);
            glContext.deleteProgram(program);
            throw new Error(info);
          }
          return program;
        }

        function hexToRgb(hex) {
          const clean = hex.replace("#", "");
          const value = parseInt(clean, 16);
          return [
            ((value >> 16) & 255) / 255,
            ((value >> 8) & 255) / 255,
            (value & 255) / 255
          ];
        }

        function createRenderTarget(width, height) {
          const texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

          const fbo = gl.createFramebuffer();
          gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);

          return { texture, fbo, width, height };
        }

        function createImageTexture(options) {
          const texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([128, 128, 128, 255]));
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, options.linear ? gl.LINEAR : gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, options.linear ? gl.LINEAR : gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.wrapS ?? gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.wrapT ?? gl.CLAMP_TO_EDGE);
          return { texture, width: 1, height: 1, loaded: false };
        }

        function updateImageTexture(tex, img, options) {
          gl.bindTexture(gl.TEXTURE_2D, tex.texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, options.linear ? gl.LINEAR : gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, options.linear ? gl.LINEAR : gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.wrapS ?? gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.wrapT ?? gl.CLAMP_TO_EDGE);
          tex.width = img.width;
          tex.height = img.height;
          tex.loaded = true;
        }

        function loadImage(url, onLoad) {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.onload = () => onLoad(img);
          img.src = url;
        }

        function getCurrentDpr() {
          return Math.min(window.devicePixelRatio || 1, config.DPR_MAX);
        }

        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 3, -1, -1, 3]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
        gl.bindVertexArray(null);

        const backgroundProgram = createProgram(gl, vertexShaderSource, backgroundFragmentSource);
        const revealProgram = createProgram(gl, vertexShaderSource, revealFragmentSource);
        const sineProgram = createProgram(gl, vertexShaderSource, sineFragmentSource);
        const shatterProgram = createProgram(gl, vertexShaderSource, shatterFragmentSource);
        const bokehProgram = createProgram(gl, vertexShaderSource, bokehFragmentSource);
        const outputProgram = createProgram(gl, vertexShaderSource, outputFragmentSource);

        const backgroundUniforms = {
          bgColor: gl.getUniformLocation(backgroundProgram, "uBgColor")
        };

        const revealUniforms = {
          prevReveal: gl.getUniformLocation(revealProgram, "tPrevReveal"),
          blueNoise: gl.getUniformLocation(revealProgram, "tBlueNoise"),
          pointerPos: gl.getUniformLocation(revealProgram, "uPointerPos"),
          pointerActive: gl.getUniformLocation(revealProgram, "uPointerActive"),
          dt: gl.getUniformLocation(revealProgram, "uDt"),
          radius: gl.getUniformLocation(revealProgram, "uRadius"),
          softness: gl.getUniformLocation(revealProgram, "uSoftness"),
          edgeSmoothness: gl.getUniformLocation(revealProgram, "uEdgeSmoothness"),
          falloff: gl.getUniformLocation(revealProgram, "uFalloff"),
          skew: gl.getUniformLocation(revealProgram, "uSkew"),
          angle: gl.getUniformLocation(revealProgram, "uAngle"),
          revealTime: gl.getUniformLocation(revealProgram, "uRevealTime"),
          fadeTime: gl.getUniformLocation(revealProgram, "uFadeTime"),
          centerColor: gl.getUniformLocation(revealProgram, "uCenterColor"),
          edgeColor: gl.getUniformLocation(revealProgram, "uEdgeColor"),
          resolution: gl.getUniformLocation(revealProgram, "uResolution"),
          blueNoiseResolution: gl.getUniformLocation(revealProgram, "uBlueNoiseResolution"),
          edgeNoiseStrength: gl.getUniformLocation(revealProgram, "uEdgeNoiseStrength"),
          edgeNoiseScale: gl.getUniformLocation(revealProgram, "uEdgeNoiseScale"),
          edgeAA: gl.getUniformLocation(revealProgram, "uEdgeAA")
        };

        const sineUniforms = {
          input: gl.getUniformLocation(sineProgram, "tInput"),
          mixRadius: gl.getUniformLocation(sineProgram, "uMixRadius"),
          pos: gl.getUniformLocation(sineProgram, "uPos"),
          frequency: gl.getUniformLocation(sineProgram, "uFrequency"),
          amplitude: gl.getUniformLocation(sineProgram, "uAmplitude"),
          rotation: gl.getUniformLocation(sineProgram, "uRotation"),
          time: gl.getUniformLocation(sineProgram, "uTime"),
          resolution: gl.getUniformLocation(sineProgram, "uResolution"),
          mouse: gl.getUniformLocation(sineProgram, "uMousePos"),
          trackMouse: gl.getUniformLocation(sineProgram, "uTrackMouse")
        };

        const shatterUniforms = {
          input: gl.getUniformLocation(shatterProgram, "tInput"),
          amount: gl.getUniformLocation(shatterProgram, "uAmount"),
          spread: gl.getUniformLocation(shatterProgram, "uSpread"),
          angle: gl.getUniformLocation(shatterProgram, "uAngle"),
          time: gl.getUniformLocation(shatterProgram, "uTime"),
          skew: gl.getUniformLocation(shatterProgram, "uSkew"),
          pos: gl.getUniformLocation(shatterProgram, "uPos"),
          resolution: gl.getUniformLocation(shatterProgram, "uResolution"),
          mixRadius: gl.getUniformLocation(shatterProgram, "uMixRadius"),
          mixInvert: gl.getUniformLocation(shatterProgram, "uMixRadiusInvert"),
          easing: gl.getUniformLocation(shatterProgram, "uEasing"),
          mouse: gl.getUniformLocation(shatterProgram, "uMousePos"),
          trackMouse: gl.getUniformLocation(shatterProgram, "uTrackMouse")
        };

        const bokehUniforms = {
          input: gl.getUniformLocation(bokehProgram, "tInput"),
          bgTexture: gl.getUniformLocation(bokehProgram, "tBgTexture"),
          blueNoise: gl.getUniformLocation(bokehProgram, "tBlueNoise"),
          amount: gl.getUniformLocation(bokehProgram, "uAmount"),
          tilt: gl.getUniformLocation(bokehProgram, "uTilt"),
          time: gl.getUniformLocation(bokehProgram, "uTime"),
          pos: gl.getUniformLocation(bokehProgram, "uPos"),
          pass: gl.getUniformLocation(bokehProgram, "uPass"),
          resolution: gl.getUniformLocation(bokehProgram, "uResolution"),
          mouse: gl.getUniformLocation(bokehProgram, "uMousePos"),
          trackMouse: gl.getUniformLocation(bokehProgram, "uTrackMouse"),
          blueNoiseResolution: gl.getUniformLocation(bokehProgram, "uBlueNoiseResolution")
        };

        const outputUniforms = {
          bgTexture: gl.getUniformLocation(outputProgram, "tBgTexture"),
          blueNoise: gl.getUniformLocation(outputProgram, "tBlueNoise"),
          bgColor: gl.getUniformLocation(outputProgram, "uBgColor"),
          input: gl.getUniformLocation(outputProgram, "tInput"),
          centerColor: gl.getUniformLocation(outputProgram, "uCenterColor"),
          bgTextureEnabled: gl.getUniformLocation(outputProgram, "uBgTextureEnabled"),
          loaded: gl.getUniformLocation(outputProgram, "uLoaded"),
          resolution: gl.getUniformLocation(outputProgram, "uResolution"),
          blueNoiseResolution: gl.getUniformLocation(outputProgram, "uBlueNoiseResolution"),
          contourNoise: gl.getUniformLocation(outputProgram, "uContourNoise")
        };

        gl.useProgram(revealProgram);
        gl.uniform1i(revealUniforms.prevReveal, 0);
        gl.uniform1i(revealUniforms.blueNoise, 1);

        gl.useProgram(sineProgram);
        gl.uniform1i(sineUniforms.input, 0);

        gl.useProgram(shatterProgram);
        gl.uniform1i(shatterUniforms.input, 0);

        gl.useProgram(bokehProgram);
        gl.uniform1i(bokehUniforms.input, 0);
        gl.uniform1i(bokehUniforms.bgTexture, 1);
        gl.uniform1i(bokehUniforms.blueNoise, 2);

        gl.useProgram(outputProgram);
        gl.uniform1i(outputUniforms.bgTexture, 1);
        gl.uniform1i(outputUniforms.input, 0);
        gl.uniform1i(outputUniforms.blueNoise, 2);

        const bgImageTexture = createImageTexture({
          wrapS: gl.REPEAT,
          wrapT: gl.REPEAT,
          linear: true
        });
        const blueNoiseTexture = createImageTexture({
          wrapS: gl.REPEAT,
          wrapT: gl.REPEAT,
          linear: false
        });

        loadImage("assets/orange-gradient.jpg", (img) => {
          updateImageTexture(bgImageTexture, img, {
            wrapS: gl.REPEAT,
            wrapT: gl.REPEAT,
            linear: true
          });
          if (!running || reducedMotion) {
            renderOnce();
          }
        });

        loadImage("assets/blue-noise.png", (img) => {
          updateImageTexture(blueNoiseTexture, img, {
            wrapS: gl.REPEAT,
            wrapT: gl.REPEAT,
            linear: false
          });
          if (!running || reducedMotion) {
            renderOnce();
          }
        });

        let backgroundTarget = null;
        let revealReadTarget = null;
        let revealWriteTarget = null;
        let pingTarget = null;
        let pongTarget = null;
        let screenWidth = 1;
        let screenHeight = 1;
        let fieldWidth = 1;
        let fieldHeight = 1;

        function resize() {
          const dpr = getCurrentDpr();
          screenWidth = Math.max(1, Math.floor(window.innerWidth * dpr));
          screenHeight = Math.max(1, Math.floor(window.innerHeight * dpr));
          canvas.width = screenWidth;
          canvas.height = screenHeight;

          fieldWidth = Math.max(1, Math.floor(screenWidth * config.RES_SCALE));
          fieldHeight = Math.max(1, Math.floor(screenHeight * config.RES_SCALE));

          if (backgroundTarget) {
            gl.deleteTexture(backgroundTarget.texture);
            gl.deleteFramebuffer(backgroundTarget.fbo);
          }
          if (revealReadTarget) {
            gl.deleteTexture(revealReadTarget.texture);
            gl.deleteFramebuffer(revealReadTarget.fbo);
          }
          if (revealWriteTarget) {
            gl.deleteTexture(revealWriteTarget.texture);
            gl.deleteFramebuffer(revealWriteTarget.fbo);
          }
          if (pingTarget) {
            gl.deleteTexture(pingTarget.texture);
            gl.deleteFramebuffer(pingTarget.fbo);
          }
          if (pongTarget) {
            gl.deleteTexture(pongTarget.texture);
            gl.deleteFramebuffer(pongTarget.fbo);
          }

          backgroundTarget = createRenderTarget(fieldWidth, fieldHeight);
          revealReadTarget = createRenderTarget(fieldWidth, fieldHeight);
          revealWriteTarget = createRenderTarget(fieldWidth, fieldHeight);
          pingTarget = createRenderTarget(fieldWidth, fieldHeight);
          pongTarget = createRenderTarget(fieldWidth, fieldHeight);
          clearRevealTargets();
        }

        const pointerTarget = { x: 0.5, y: 0.5 };
        const pointerCurrent = { x: 0.5, y: 0.5 };
        let pointerActive = false;

        function updatePointer(event) {
          const x = event.clientX / window.innerWidth;
          const y = 1 - event.clientY / window.innerHeight;
          pointerTarget.x = Math.min(1, Math.max(0, x));
          pointerTarget.y = Math.min(1, Math.max(0, y));
          pointerActive = true;
        }

        function deactivatePointer() {
          pointerActive = false;
        }

        window.addEventListener("pointermove", updatePointer, { passive: true });
        window.addEventListener("pointerleave", deactivatePointer, { passive: true });
        window.addEventListener("pointercancel", deactivatePointer, { passive: true });
        window.addEventListener("blur", deactivatePointer);

        function bindTarget(target) {
          if (target) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
            gl.viewport(0, 0, target.width, target.height);
          } else {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, screenWidth, screenHeight);
          }
        }

        function clearTarget(target, r, g, b, a) {
          bindTarget(target);
          gl.clearColor(r, g, b, a);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }

        function clearRevealTargets() {
          if (!revealReadTarget || !revealWriteTarget) {
            return;
          }
          const center = hexToRgb(config.PARTICLE_CENTER_COLOR);
          clearTarget(revealReadTarget, center[0], center[1], center[2], 0.0);
          clearTarget(revealWriteTarget, center[0], center[1], center[2], 0.0);
          bindTarget(null);
        }

        function renderBackground(target) {
          gl.useProgram(backgroundProgram);
          bindTarget(target);
          gl.bindVertexArray(vao);
          const bg = hexToRgb(config.BG_COLOR);
          gl.uniform3f(backgroundUniforms.bgColor, bg[0], bg[1], bg[2]);
          gl.drawArrays(gl.TRIANGLES, 0, 3);
        }

        function renderReveal(deltaSeconds, inputTarget, outputTarget) {
          gl.useProgram(revealProgram);
          bindTarget(outputTarget);
          gl.bindVertexArray(vao);
          const center = hexToRgb(config.PARTICLE_CENTER_COLOR);
          const edge = hexToRgb(config.PARTICLE_EDGE_COLOR);
          gl.uniform2f(revealUniforms.pointerPos, pointerCurrent.x, pointerCurrent.y);
          gl.uniform1f(revealUniforms.pointerActive, pointerActive ? 1 : 0);
          gl.uniform1f(revealUniforms.dt, Math.max(0, deltaSeconds));
          gl.uniform1f(revealUniforms.radius, config.PARTICLE_RADIUS);
          gl.uniform1f(revealUniforms.softness, config.PARTICLE_SOFTNESS);
          gl.uniform1f(revealUniforms.edgeSmoothness, config.PARTICLE_EDGE_SMOOTHNESS);
          gl.uniform1f(revealUniforms.falloff, INTERNAL_SHAPE.FALL_OFF);
          gl.uniform1f(revealUniforms.skew, INTERNAL_SHAPE.SKEW);
          gl.uniform1f(revealUniforms.angle, INTERNAL_SHAPE.ANGLE);
          gl.uniform1f(revealUniforms.revealTime, config.PARTICLE_REVEAL_TIME);
          gl.uniform1f(revealUniforms.fadeTime, config.PARTICLE_FADE_TIME);
          gl.uniform3f(revealUniforms.centerColor, center[0], center[1], center[2]);
          gl.uniform3f(revealUniforms.edgeColor, edge[0], edge[1], edge[2]);
          gl.uniform2f(revealUniforms.resolution, fieldWidth, fieldHeight);
          gl.uniform2f(revealUniforms.blueNoiseResolution, blueNoiseTexture.width, blueNoiseTexture.height);
          gl.uniform1f(revealUniforms.edgeNoiseStrength, config.PARTICLE_CONTOUR_NOISE);
          gl.uniform1f(revealUniforms.edgeNoiseScale, INTERNAL_SHAPE.EDGE_NOISE_SCALE);
          gl.uniform1f(revealUniforms.edgeAA, INTERNAL_SHAPE.EDGE_AA);

          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, inputTarget.texture);
          gl.activeTexture(gl.TEXTURE1);
          gl.bindTexture(gl.TEXTURE_2D, blueNoiseTexture.texture);

          gl.drawArrays(gl.TRIANGLES, 0, 3);
        }

        function renderSine(time, inputTarget, outputTarget) {
          gl.useProgram(sineProgram);
          bindTarget(outputTarget);
          gl.bindVertexArray(vao);
          gl.uniform1f(sineUniforms.mixRadius, config.SINE_MIX_RADIUS);
          gl.uniform2f(sineUniforms.pos, 0.5, 0.5);
          gl.uniform1f(sineUniforms.frequency, config.SINE_FREQUENCY);
          gl.uniform1f(sineUniforms.amplitude, config.SINE_AMPLITUDE);
          gl.uniform1f(sineUniforms.rotation, config.SINE_ROTATION);
          gl.uniform1f(sineUniforms.time, time);
          gl.uniform2f(sineUniforms.resolution, fieldWidth, fieldHeight);
          gl.uniform2f(sineUniforms.mouse, pointerCurrent.x, pointerCurrent.y);
          gl.uniform1f(sineUniforms.trackMouse, config.SINE_TRACK_MOUSE);

          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, inputTarget.texture);

          gl.drawArrays(gl.TRIANGLES, 0, 3);
        }

        function renderShatter(time, inputTarget, outputTarget) {
          gl.useProgram(shatterProgram);
          bindTarget(outputTarget);
          gl.bindVertexArray(vao);
          gl.uniform1f(shatterUniforms.amount, config.SHATTER_SCALE);
          gl.uniform1f(shatterUniforms.spread, config.SHATTER_AMOUNT);
          gl.uniform1f(shatterUniforms.angle, config.SHATTER_ANGLE / 360);
          gl.uniform1f(shatterUniforms.time, time);
          gl.uniform1f(shatterUniforms.skew, config.SHATTER_SKEW);
          gl.uniform2f(shatterUniforms.pos, 0.5, 0.5);
          gl.uniform2f(shatterUniforms.resolution, fieldWidth, fieldHeight);
          gl.uniform1f(shatterUniforms.mixRadius, config.SHATTER_MIX_RADIUS);
          gl.uniform1i(shatterUniforms.mixInvert, Math.round(config.SHATTER_MIX_INVERT));
          gl.uniform1i(shatterUniforms.easing, 0);
          gl.uniform2f(shatterUniforms.mouse, pointerCurrent.x, pointerCurrent.y);
          gl.uniform1f(shatterUniforms.trackMouse, 0.0);

          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, inputTarget.texture);

          gl.drawArrays(gl.TRIANGLES, 0, 3);
        }

        function renderBokeh(time, inputTarget, outputTarget) {
          gl.useProgram(bokehProgram);
          bindTarget(outputTarget);
          gl.bindVertexArray(vao);
          gl.uniform1f(bokehUniforms.amount, config.BOKEH_RADIUS);
          gl.uniform1f(bokehUniforms.tilt, config.BOKEH_TILT);
          gl.uniform1f(bokehUniforms.time, time);
          gl.uniform2f(bokehUniforms.pos, 0.5, 0.5);
          gl.uniform1i(bokehUniforms.pass, 0);
          gl.uniform2f(bokehUniforms.resolution, fieldWidth, fieldHeight);
          gl.uniform2f(bokehUniforms.mouse, pointerCurrent.x, pointerCurrent.y);
          gl.uniform1f(bokehUniforms.trackMouse, config.BOKEH_TRACK_MOUSE);
          gl.uniform2f(bokehUniforms.blueNoiseResolution, blueNoiseTexture.width, blueNoiseTexture.height);

          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, inputTarget.texture);
          gl.activeTexture(gl.TEXTURE1);
          gl.bindTexture(gl.TEXTURE_2D, backgroundTarget.texture);
          gl.activeTexture(gl.TEXTURE2);
          gl.bindTexture(gl.TEXTURE_2D, blueNoiseTexture.texture);

          gl.drawArrays(gl.TRIANGLES, 0, 3);
        }

        function renderOutput(inputTarget) {
          gl.useProgram(outputProgram);
          bindTarget(null);
          gl.bindVertexArray(vao);
          const bg = hexToRgb(config.BG_COLOR);
          const center = hexToRgb(config.PARTICLE_CENTER_COLOR);
          gl.uniform3f(outputUniforms.bgColor, bg[0], bg[1], bg[2]);
          gl.uniform3f(outputUniforms.centerColor, center[0], center[1], center[2]);
          gl.uniform1i(outputUniforms.bgTextureEnabled, Math.round(config.BG_TEXTURE_ENABLED));
          gl.uniform1i(outputUniforms.loaded, bgImageTexture.loaded ? 1 : 0);
          gl.uniform2f(outputUniforms.resolution, fieldWidth, fieldHeight);
          gl.uniform2f(outputUniforms.blueNoiseResolution, blueNoiseTexture.width, blueNoiseTexture.height);
          gl.uniform1f(outputUniforms.contourNoise, config.PARTICLE_CONTOUR_NOISE);

          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, inputTarget.texture);
          gl.activeTexture(gl.TEXTURE1);
          gl.bindTexture(gl.TEXTURE_2D, bgImageTexture.texture);
          gl.activeTexture(gl.TEXTURE2);
          gl.bindTexture(gl.TEXTURE_2D, blueNoiseTexture.texture);

          gl.drawArrays(gl.TRIANGLES, 0, 3);
        }

        const mediaQuery = window.matchMedia("(prefers-reduced-motion: reduce)");
        let reducedMotion = mediaQuery.matches;
        let time = 0;
        let lastTime = 0;
        let rafId = 0;
        let running = false;

        let statsFrames = 0;
        let statsTimeSum = 0;
        let statsLast = performance.now();

        const statFps = document.getElementById("statFps");
        const statFrame = document.getElementById("statFrame");
        const statRender = document.getElementById("statRender");
        const statPixels = document.getElementById("statPixels");
        const statResScale = document.getElementById("statResScale");
        const statDpr = document.getElementById("statDpr");
        const statPasses = document.getElementById("statPasses");

        function updateResourceStats() {
          statRender.textContent = `${fieldWidth} x ${fieldHeight}`;
          statPixels.textContent = `${(fieldWidth * fieldHeight / 1000000).toFixed(2)} MP`;
          statResScale.textContent = config.RES_SCALE.toFixed(2);
          const dpr = getCurrentDpr();
          statDpr.textContent = `${dpr.toFixed(2)} / ${config.DPR_MAX.toFixed(2)}`;
          statPasses.textContent = `6`;
        }

        function updateFpsStats(delta, now) {
          statsFrames += 1;
          statsTimeSum += delta;
          if (now - statsLast >= 500) {
            const avgFrame = statsFrames > 0 ? statsTimeSum / statsFrames : 0;
            const fps = avgFrame > 0 ? 1000 / avgFrame : 0;
            statFps.textContent = fps > 0 ? fps.toFixed(1) : "--";
            statFrame.textContent = avgFrame > 0 ? `${avgFrame.toFixed(1)} ms` : "--";
            statsFrames = 0;
            statsTimeSum = 0;
            statsLast = now;
          }
        }

        function drawFrame(now) {
          if (!running) {
            return;
          }
          const delta = now - lastTime;
          lastTime = now;
          time += delta * 0.001 * 2.0;

          if (reducedMotion) {
            pointerCurrent.x = 0.5;
            pointerCurrent.y = 0.5;
          } else {
            pointerCurrent.x += (pointerTarget.x - pointerCurrent.x) * config.POINTER_SMOOTHING;
            pointerCurrent.y += (pointerTarget.y - pointerCurrent.y) * config.POINTER_SMOOTHING;
          }

          const deltaSeconds = Math.max(0, delta * 0.001);
          renderBackground(backgroundTarget);
          renderReveal(deltaSeconds, revealReadTarget, revealWriteTarget);
          [revealReadTarget, revealWriteTarget] = [revealWriteTarget, revealReadTarget];
          renderSine(time, revealReadTarget, pingTarget);
          renderShatter(time, pingTarget, pongTarget);
          renderBokeh(time, pongTarget, pingTarget);
          renderOutput(pingTarget);

          updateFpsStats(delta, now);
          rafId = requestAnimationFrame(drawFrame);
        }

        function renderOnce() {
          renderBackground(backgroundTarget);
          renderReveal(0, revealReadTarget, revealWriteTarget);
          [revealReadTarget, revealWriteTarget] = [revealWriteTarget, revealReadTarget];
          renderSine(time, revealReadTarget, pingTarget);
          renderShatter(time, pingTarget, pongTarget);
          renderBokeh(time, pongTarget, pingTarget);
          renderOutput(pingTarget);
        }

        function start() {
          if (running || reducedMotion || document.hidden) {
            return;
          }
          running = true;
          lastTime = performance.now();
          statsLast = lastTime;
          statsFrames = 0;
          statsTimeSum = 0;
          rafId = requestAnimationFrame(drawFrame);
        }

        function stop() {
          running = false;
          if (rafId) {
            cancelAnimationFrame(rafId);
            rafId = 0;
          }
        }

        function handleVisibilityChange() {
          if (document.hidden) {
            stop();
            pointerActive = false;
          } else if (!reducedMotion) {
            start();
          }
        }

        function handleMotionChange(event) {
          reducedMotion = event.matches;
          if (reducedMotion) {
            stop();
            pointerActive = false;
            pointerCurrent.x = 0.5;
            pointerCurrent.y = 0.5;
            clearRevealTargets();
            renderOnce();
          } else {
            start();
          }
        }

        if (mediaQuery.addEventListener) {
          mediaQuery.addEventListener("change", handleMotionChange);
        } else if (mediaQuery.addListener) {
          mediaQuery.addListener(handleMotionChange);
        }

        document.addEventListener("visibilitychange", handleVisibilityChange);
        window.addEventListener("resize", () => {
          resize();
          updateResourceStats();
          renderOnce();
        });

        const controlsRoot = document.getElementById("controlSections");
        const panel = document.getElementById("controlPanel");
        const panelToggle = document.getElementById("panelToggle");
        const resetButton = document.getElementById("resetControls");

        const CONTROL_DEFS = [
          { id: "BG_COLOR", label: "Background", group: "Colors", type: "color" },
          { id: "PARTICLE_CENTER_COLOR", label: "Particle Center", group: "Colors", type: "color" },
          { id: "PARTICLE_EDGE_COLOR", label: "Particle Edge", group: "Colors", type: "color" },
          { id: "BG_TEXTURE_ENABLED", label: "Background Texture", group: "Colors", type: "checkbox" },
          { id: "PARTICLE_RADIUS", label: "Radius", group: "Particle", type: "range", min: 0.05, max: 1, step: 0.01, decimals: 2 },
          { id: "PARTICLE_SOFTNESS", label: "Softness", group: "Particle", type: "range", min: 0.2, max: 3, step: 0.05, decimals: 2 },
          { id: "PARTICLE_EDGE_SMOOTHNESS", label: "Edge Smoothness", group: "Particle", type: "range", min: 0.2, max: 4, step: 0.05, decimals: 2 },
          { id: "PARTICLE_CONTOUR_NOISE", label: "Contour Noise", group: "Particle", type: "range", min: 0.0, max: 1.5, step: 0.01, decimals: 2 },
          { id: "PARTICLE_REVEAL_TIME", label: "Reveal Time", group: "Particle", type: "range", min: 0.02, max: 1.5, step: 0.01, decimals: 2, suffix: "s" },
          { id: "PARTICLE_FADE_TIME", label: "Fade Time", group: "Particle", type: "range", min: 0.1, max: 3, step: 0.01, decimals: 2, suffix: "s" },
          { id: "SINE_FREQUENCY", label: "Frequency", group: "Sine", type: "range", min: 0, max: 1, step: 0.01, decimals: 2 },
          { id: "SINE_AMPLITUDE", label: "Amplitude", group: "Sine", type: "range", min: 0, max: 2, step: 0.01, decimals: 2 },
          { id: "SINE_FALLOFF", label: "Falloff", group: "Sine", type: "range", min: 0, max: 1, step: 0.01, decimals: 2 },
          { id: "SINE_ROTATION", label: "Rotation", group: "Sine", type: "range", min: 0, max: 1, step: 0.01, decimals: 2 },
          { id: "SINE_PHASE", label: "Phase", group: "Sine", type: "range", min: 0, max: 1, step: 0.01, decimals: 2 },
          { id: "SINE_SPEED", label: "Speed", group: "Sine", type: "range", min: 0, max: 1, step: 0.01, decimals: 2 },
          { id: "SINE_MIX_RADIUS", label: "Mix Radius", group: "Sine", type: "range", min: 0, max: 1, step: 0.01, decimals: 2 },
          { id: "SINE_TRACK_MOUSE", label: "Track Mouse", group: "Sine", type: "range", min: 0, max: 1, step: 0.01, decimals: 2 },
          { id: "SHATTER_SCALE", label: "Scale", group: "Shatter", type: "range", min: 0, max: 2, step: 0.01, decimals: 2 },
          { id: "SHATTER_AMOUNT", label: "Amount", group: "Shatter", type: "range", min: 0, max: 2, step: 0.01, decimals: 2 },
          { id: "SHATTER_ANGLE", label: "Angle", group: "Shatter", type: "range", min: 0, max: 180, step: 1, decimals: 0, suffix: "" },
          { id: "SHATTER_RADIUS", label: "Radius", group: "Shatter", type: "range", min: 0, max: 2, step: 0.01, decimals: 2 },
          { id: "SHATTER_SKEW", label: "Skew", group: "Shatter", type: "range", min: 0, max: 1, step: 0.01, decimals: 2 },
          { id: "SHATTER_MIX_RADIUS", label: "Mix Radius", group: "Shatter", type: "range", min: 0, max: 1, step: 0.01, decimals: 2 },
          { id: "SHATTER_MIX_INVERT", label: "Mix Invert", group: "Shatter", type: "range", min: 0, max: 1, step: 1, decimals: 0, integer: true },
          { id: "BOKEH_RADIUS", label: "Radius", group: "Bokeh", type: "range", min: 0, max: 2, step: 0.01, decimals: 2 },
          { id: "BOKEH_TILT", label: "Tilt", group: "Bokeh", type: "range", min: 0, max: 1, step: 0.01, decimals: 2 },
          { id: "BOKEH_MIX_RADIUS", label: "Mix Radius", group: "Bokeh", type: "range", min: 0, max: 1, step: 0.01, decimals: 2 },
          { id: "BOKEH_TRACK_MOUSE", label: "Track Mouse", group: "Bokeh", type: "range", min: 0, max: 1, step: 0.01, decimals: 2 },
          { id: "POINTER_SMOOTHING", label: "Smoothing", group: "Pointer", type: "range", min: 0.02, max: 0.2, step: 0.005, decimals: 3 },
          { id: "RES_SCALE", label: "Resolution Scale", group: "Performance", type: "range", min: 0.25, max: 1, step: 0.05, decimals: 2, resize: true },
          { id: "DPR_MAX", label: "Max DPR", group: "Performance", type: "range", min: 1, max: 3, step: 0.1, decimals: 1, resize: true }
        ];

        const controlMap = new Map();

        function getDefValue(def) {
          return config[def.id];
        }

        function setDefValue(def, value) {
          config[def.id] = value;
        }

        function formatValue(def, value) {
          if (def.type === "color") {
            return value.toUpperCase();
          }
          if (def.type === "checkbox") {
            return Number(value) === 1 ? "On" : "Off";
          }
          const decimals = def.decimals ?? 2;
          const text = Number(value).toFixed(decimals);
          return def.suffix ? `${text}${def.suffix}` : text;
        }

        function syncControls() {
          controlMap.forEach(({ def, input, valueEl }) => {
            const value = getDefValue(def);
            if (def.type === "checkbox") {
              input.checked = Number(value) === 1;
            } else {
              input.value = value;
            }
            valueEl.textContent = formatValue(def, value);
          });
        }

        function applyConfigChange(def) {
          if (
            def.id === "PARTICLE_CENTER_COLOR" ||
            def.id === "PARTICLE_EDGE_COLOR" ||
            def.id === "PARTICLE_RADIUS" ||
            def.id === "PARTICLE_SOFTNESS" ||
            def.id === "PARTICLE_EDGE_SMOOTHNESS" ||
            def.id === "PARTICLE_CONTOUR_NOISE"
          ) {
            clearRevealTargets();
          }
          if (def.resize) {
            resize();
          }
          updateResourceStats();
          saveConfig();
          if (!running || reducedMotion) {
            renderOnce();
          }
        }

        function buildControls() {
          const sections = new Map();
          CONTROL_DEFS.forEach((def) => {
            let section = sections.get(def.group);
            if (!section) {
              const wrapper = document.createElement("div");
              wrapper.className = "panel-section";

              const title = document.createElement("div");
              title.className = "section-title";
              title.textContent = def.group;
              wrapper.appendChild(title);

              const list = document.createElement("div");
              list.className = "control-list";
              wrapper.appendChild(list);

              controlsRoot.appendChild(wrapper);
              sections.set(def.group, list);
              section = list;
            }

            const row = document.createElement("div");
            row.className = "control-row";

            const label = document.createElement("label");
            label.className = "control-label";
            label.textContent = def.label;

            const valueEl = document.createElement("span");
            valueEl.className = "control-value";
            label.appendChild(valueEl);

            const inputWrap = document.createElement("div");
            inputWrap.className = "control-input";

            const input = document.createElement("input");
            input.type = def.type;
            input.id = `control-${def.id}`;

            if (def.type === "range") {
              input.min = def.min;
              input.max = def.max;
              input.step = def.step;
            }

            label.htmlFor = input.id;
            inputWrap.appendChild(input);

            row.appendChild(label);
            row.appendChild(inputWrap);
            section.appendChild(row);

            controlMap.set(def.id, { def, input, valueEl });

            input.addEventListener("input", () => {
              let value = def.type === "color" ? input.value : Number(input.value);
              if (def.type === "checkbox") {
                value = input.checked ? 1 : 0;
              }
              if (def.integer) {
                value = Math.round(value);
              }
              setDefValue(def, value);
              syncControls();
              applyConfigChange(def);
            });
          });
        }

        function resetConfig() {
          const fresh = cloneDefaults();
          Object.keys(fresh).forEach((key) => {
            config[key] = fresh[key];
          });
          resize();
          clearRevealTargets();
          syncControls();
          updateResourceStats();
          saveConfig();
          renderOnce();
        }

        panelToggle.addEventListener("click", () => {
          panel.classList.toggle("collapsed");
          panelToggle.textContent = panel.classList.contains("collapsed") ? "Show" : "Hide";
        });

        resetButton.addEventListener("click", resetConfig);

        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);

        resize();
        buildControls();
        syncControls();
        updateResourceStats();
        renderOnce();
        start();
      })();
    </script>
  </body>
</html>
